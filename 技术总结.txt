*有符号和无符号进行大小比较时，会隐式转换成无符号进行比较。
*有符号数做加法，可能越界变负数；无符号数做减法，超过0就会超界变成42亿的超大数（32位）。
*有符号数做减法，可能越界借位；无符号数做加法，可能越界产生截断。
*相同长度的有符号数和无符号数能装的数据量都是一样大的，正数和负数只是表示的方式不同（%u和%d）。
*枚举的内存结构和联合类似，一个枚举的字长和int一样，都是4字节。

*TCP协议如何保证传输完整性: 1. 分包 2. 超时重发 3. 完整性校验, 如果完整, 发送确认, 如果不完整, 丢弃数据包
                            4. 重新排序 5. 丢弃重复数据 6. 流量控制, 防止缓冲区溢出.
*同步：调用系统函数后主动查询状态。	异步：调用系统函数后系统主动通知。
 阻塞：等待系统函数执行完后返回。	非阻塞：调用系统函数后立即返回，后面再主动查询（同步）或者等待系统通知（异步）。
*git的有三个仓库：cache索引、本地仓库、远程仓库
 git diff : 本地代码与cache索引的区别
 git diff --cached : cache索引与本地仓库的区别
 git add : 从本地代码添加到cache索引
 git commit : 从cache索引添加到本地仓库
 git push : 从本地仓库推送到远程仓库
*对于动态库内的全局变量和函数，如果应用层有同名的变量或者函数，则会覆盖动态库内的全局变量和函数。
 如果没有同名的，则正常调用动态库内的全局变量或者函数。
*C语言中的assert只在-g编绎下，即调试模式下才会发挥作用。
*死循环要想降低CPU使用率，必须在死循环中调用休眠函数，在协程切换间调用休眠函数不起作用。
*防外挂手段：注册限制、借助第三方硬件。
*C++中的类，类的动态函数必须通过类的对象来进行访问。类的静态函数既可以直接访问，也可以通过对象访问。
*在64位机器上：long类型-8字节，int类型-4字节，short类型-2字节，char类型-1字节，枚举-4字节，指针-8字节。